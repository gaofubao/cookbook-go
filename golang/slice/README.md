# Slice

## Slice 实现原理
---
slice 是基于数组实现的，它的底层是数组，可以理解为对底层数组的抽象。
源码包中 src/runtime/slice.go 定义了 slice 的数据结构：
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
slice 占用 24 个字节
- array: 指向底层数组的指针，占用 8 个字节
- len: 切片的长度，占用 8 个字节
- cap: 切片的容量，cap 总是大于等于 len 的，占用 8 个字节

slice 有 4 种初始化方式：
```go
// 初始化方式1：直接声明
var slice1 []int

// 初始化方式2：使用字面量
slice2 := []int{1, 2, 3, 4}

// 初始化方式3：使用make创建slice
slice3 := make([]int, 3, 5)         

// 初始化方式4: 从切片或数组“截取”
slcie4 := arr[1:3]
```

通过一个简单程序，看下 slice 初始化调用的底层函数：
```go
func main() {
	slice := make([]int, 0)
	slice = append(slice, 1)
	fmt.Println(slice, len(slice), cap(slice))
}
```
通过 go tool compile -S test.go | grep CALL 得到汇编代码：
```shell
0x0042 00066 (test.go:6)        CALL    runtime.makeslice(SB)
0x006d 00109 (test.go:7)        CALL    runtime.growslice(SB)
0x00a4 00164 (test.go:8)        CALL    runtime.convTslice(SB)
0x00c0 00192 (test.go:8)        CALL    runtime.convT64(SB)
0x00d8 00216 (test.go:8)        CALL    runtime.convT64(SB)
0x0166 00358 ($GOROOT/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)
0x0180 00384 (test.go:5)        CALL    runtime.morestack_noctxt(SB)
0x0079 00121 (<autogenerated>:1)        CALL    runtime.efaceeq(SB)
0x00a0 00160 (<autogenerated>:1)        CALL    runtime.morestack_noctxt(SB)
```
初始化 slice 调用的是 runtime.makeslice，makeslice 函数的工作主要就是计算 slice 所需内存大小，然后调用 mallocgc 进行内存的分配。
所需内存大小 = 切片中元素大小 * 切片的容量
```go
func makeslice(et *_type, len, cap int) unsafe.Pointer {
    mem, overflow := math.MulUintptr(et.size, uintptr(cap))
    if overflow || mem > maxAlloc || len < 0 || len > cap {
        // NOTE: Produce a 'len out of range' error instead of a
        // 'cap out of range' error when someone does make([]T, bignumber).
        // 'cap out of range' is true too, but since the cap is only being
        // supplied implicitly, saying len is clearer.
        // See golang.org/issue/4085.
        mem, overflow := math.MulUintptr(et.size, uintptr(len))
        if overflow || mem > maxAlloc || len < 0 {
            panicmakeslicelen()
        }
        panicmakeslicecap()
    }

    return mallocgc(mem, et, true)
}
```

## Slice 与 Array 区别
---

## Slice 深拷贝与浅拷贝
---
### 深拷贝
深拷贝：拷贝的是数据本身，创造一个新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值
实现深拷贝的方式：
- copy(slice2, slice1)
- 遍历 append 赋值

```go
func main() {
	slice1 := []int{1, 2, 3, 4, 5}
	fmt.Printf("slice1: %v, %p\n", slice1, slice1)

	slice2 := make([]int, 5, 5)
	copy(slice2, slice1)
	fmt.Printf("slice2: %v, %p\n", slice2, slice2)

	slice3 := make([]int, 0, 5)
	for _, v := range slice1 {
		slice3 = append(slice3, v)
	}
	fmt.Printf("slice3: %v, %p\n", slice3, slice3)
}
```
查看结果：
```shell
slice1: [1 2 3 4 5], 0xc0000aa060
slice2: [1 2 3 4 5], 0xc0000aa090
slice3: [1 2 3 4 5], 0xc0000aa0c0
```

### 浅拷贝 
浅拷贝：拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化
实现浅拷贝的方式：
- 引用类型的变量，默认赋值操作就是浅拷贝

```go
func main() {
	slice1 := []int{1, 2, 3, 4, 5}
	fmt.Printf("slice1: %v, %p\n", slice1, slice1)

	slice2 := slice1
	fmt.Printf("slice2: %v, %p\n", slice2, slice2)
}
```
查看结果：
```shell
slice1: [1 2 3 4 5], 0xc000116030
slice2: [1 2 3 4 5], 0xc000116030
```

## Slice 扩容机制
---
扩容会发生在 slice append 的时候，当 slice 的 cap 不足以容纳新元素，就会进行扩容，扩容规则如下
- 如果新申请容量比两倍原有容量大，那么扩容后容量大小为新申请容量
- 如果原有 slice 长度小于 1024，那么每次就扩容为原来的 2 倍
- 如果原 slice 长度大于等于 1024，那么每次扩容就扩为原来的 1.25 倍

```go
func main() {
	slice1 := []int{1, 2, 3}
	for i := 0; i < 16; i++ {
		slice1 = append(slice1, 1)
		fmt.Printf("addr: %p, len: %v, cap: %v\n", slice1, len(slice1), cap(slice1))
	}
}
```
查看结果：
```shell
addr: 0xc000116030, len: 4, cap: 6
addr: 0xc000116030, len: 5, cap: 6
addr: 0xc000116030, len: 6, cap: 6
addr: 0xc00011e000, len: 7, cap: 12
addr: 0xc00011e000, len: 8, cap: 12
addr: 0xc00011e000, len: 9, cap: 12
addr: 0xc00011e000, len: 10, cap: 12
addr: 0xc00011e000, len: 11, cap: 12
addr: 0xc00011e000, len: 12, cap: 12
addr: 0xc000120000, len: 13, cap: 24
addr: 0xc000120000, len: 14, cap: 24
addr: 0xc000120000, len: 15, cap: 24
addr: 0xc000120000, len: 16, cap: 24
addr: 0xc000120000, len: 17, cap: 24
addr: 0xc000120000, len: 18, cap: 24
addr: 0xc000120000, len: 19, cap: 24
```

## Slice 非线程安全
---
线程安全的定义：
- 多个线程访问同一个对象时，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。
- 若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

Go 语言实现线程安全常用的几种方式：
- 互斥锁
- 读写锁
- 原子操作
- sync.once
- sync.atomic
- channel

slice 底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致; slice 在并发执行中不会报错，但是数据会丢失。
```go
func main() {
	a := make([]int, 0)
	var wg sync.WaitGroup

	for i := 0; i < 10000; i++ {
		wg.Add(1)
		go func(i int) {
			a = append(a, i)
			wg.Done()
		}(i)
	}

	wg.Wait()
	fmt.Println(len(a))
}
```
